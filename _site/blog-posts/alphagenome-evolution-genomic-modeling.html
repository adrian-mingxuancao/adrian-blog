<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Adrian">
<meta name="dcterms.date" content="2025-08-02">

<title>AlphaGenome Evolution: Advancing Regulatory Variant Prediction and Genomic Modeling – Adrian’s Generative Genomics Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e2ec580592f0bca8c79b521847304919.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Adrian’s Generative Genomics Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog-posts/"> 
<span class="menu-text">Blog Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a>
  <ul class="collapse">
  <li><a href="#model-architecture-u-net-design-with-transformers-and-multi-resolution-output" id="toc-model-architecture-u-net-design-with-transformers-and-multi-resolution-output" class="nav-link" data-scroll-target="#model-architecture-u-net-design-with-transformers-and-multi-resolution-output">Model Architecture: U-Net Design with Transformers and Multi-Resolution Output</a></li>
  <li><a href="#training-strategy-two-stage-pre-training-and-distillation" id="toc-training-strategy-two-stage-pre-training-and-distillation" class="nav-link" data-scroll-target="#training-strategy-two-stage-pre-training-and-distillation">Training Strategy: Two-Stage Pre-training and Distillation</a></li>
  <li><a href="#comparison-to-enformer-context-length-resolution-and-directional-prediction" id="toc-comparison-to-enformer-context-length-resolution-and-directional-prediction" class="nav-link" data-scroll-target="#comparison-to-enformer-context-length-resolution-and-directional-prediction">Comparison to Enformer: Context Length, Resolution, and Directional Prediction</a></li>
  </ul></li>
  <li><a href="#variant-effect-prediction-across-modalities" id="toc-variant-effect-prediction-across-modalities" class="nav-link" data-scroll-target="#variant-effect-prediction-across-modalities">Variant Effect Prediction Across Modalities</a>
  <ul class="collapse">
  <li><a href="#splicing-variants-unified-splice-site-usage-and-junction-prediction" id="toc-splicing-variants-unified-splice-site-usage-and-junction-prediction" class="nav-link" data-scroll-target="#splicing-variants-unified-splice-site-usage-and-junction-prediction">Splicing Variants: Unified Splice Site, Usage, and Junction Prediction</a></li>
  <li><a href="#gene-expression-and-regulatory-variants-eqtls-and-enhancer-effects" id="toc-gene-expression-and-regulatory-variants-eqtls-and-enhancer-effects" class="nav-link" data-scroll-target="#gene-expression-and-regulatory-variants-eqtls-and-enhancer-effects">Gene Expression and Regulatory Variants: eQTLs and Enhancer Effects</a></li>
  </ul></li>
  <li><a href="#cross-modality-integration-and-future-directions-with-genomic-language-models" id="toc-cross-modality-integration-and-future-directions-with-genomic-language-models" class="nav-link" data-scroll-target="#cross-modality-integration-and-future-directions-with-genomic-language-models">Cross-Modality Integration and Future Directions with Genomic Language Models</a>
  <ul class="collapse">
  <li><a href="#example-applications" id="toc-example-applications" class="nav-link" data-scroll-target="#example-applications">Example Applications</a></li>
  </ul></li>
  <li><a href="#authors-reflections-and-open-issues" id="toc-authors-reflections-and-open-issues" class="nav-link" data-scroll-target="#authors-reflections-and-open-issues">Authors’ Reflections and Open Issues</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">AlphaGenome Evolution: Advancing Regulatory Variant Prediction and Genomic Modeling</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Genomics</div>
    <div class="quarto-category">Generative Modeling</div>
    <div class="quarto-category">Bioinformatics</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Adrian </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 2, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p><strong>AlphaGenome</strong> is a deep learning model that processes <strong>1 megabase (Mb) of DNA sequence</strong> to predict a broad range of functional genomic outputs at high resolution. Developed by Google DeepMind, AlphaGenome unifies multimodal genomic prediction, long-range sequence context, and <strong>single base-pair resolution</strong> into one framework. It generates <strong>5,930 human (or 1,128 mouse) genome tracks</strong> covering 11 data modalities – including gene expression (RNA-seq, CAGE, PRO-cap), splicing (splice sites, splice site usage, splice junctions), chromatin accessibility (DNase, ATAC-seq), histone marks, transcription factor binding, and 3D chromatin contacts. Trained jointly on human and mouse genomes, AlphaGenome achieves or exceeds state-of-the-art performance on the vast majority of benchmarks, matching or outperforming the best available models on <strong>24 out of 26 variant effect prediction tasks</strong>. In doing so, it addresses longstanding trade-offs in genome modeling by capturing both distal regulatory context and nucleotide-level detail, enabling more accurate predictions of how genetic variants influence gene regulation. This report provides a detailed overview of AlphaGenome’s methodology – including its architecture, training strategy, improvements over the earlier Enformer model, variant effect prediction performance across multiple modalities, and speculations on integrating AlphaGenome with genomic language models.</p>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<section id="model-architecture-u-net-design-with-transformers-and-multi-resolution-output" class="level3">
<h3 class="anchored" data-anchor-id="model-architecture-u-net-design-with-transformers-and-multi-resolution-output">Model Architecture: U-Net Design with Transformers and Multi-Resolution Output</h3>
<p><strong>U-Net–style Encoder–Decoder</strong>: AlphaGenome’s architecture follows a <strong>U-Net inspired design</strong>, consisting of an <strong>encoder</strong> that progressively downsamples the input sequence, a <strong>“Transformer Tower”</strong> that integrates long-range information, and a <strong>decoder</strong> that upsamples back to high resolution outputs. The encoder–decoder structure is similar to those in image segmentation (U-Net) but adapted for 1D genomic sequences. The <strong>sequence encoder</strong> uses multiple convolutional blocks and pooling to reduce the sequence length while increasing channel depth, extracting hierarchical features at increasing scales. Starting from 1 bp resolution with 768 channels, the encoder downsamples through 7 stages (with max-pooling by 2 at each stage) to a final <strong>128 bp resolution</strong> latent representation with 1536 channels. Convolutional filters capture local sequence motifs (e.g.&nbsp;transcription factor binding sites, splice signals) needed for base-level precision. Residual connections (“skip” connections) from the encoder layers are carried into the decoder, as in U-Net, to preserve fine-grained spatial information. The <strong>sequence decoder</strong> upsamples the latent representation back toward higher resolutions, merging with encoder skip features to output predictions at multiple scales (including single-nucleotide resolution for certain tracks). This multi-resolution design allows AlphaGenome to output different genomic tracks at the appropriate resolution for each assay – for example, base-pair resolution for splice site usage or transcription start sites, and binned resolution for broader signals like contacts.</p>
<p><strong>Transformer Layers for Long-Range Context</strong>: Between encoder and decoder, AlphaGenome inserts a stack of <strong>Transformer blocks</strong> (the “Transformer Tower”) operating on the 128 bp-resolution encoded sequence. <strong>Nine transformer layers</strong> model coarse <strong>but long-range dependencies</strong> across the entire 1 Mb input, such as distal enhancer–promoter interactions or coordinated chromatin state changes. These transformers use <strong>multi-head self-attention</strong> to allow any position in the 1 Mb sequence to attend to any other, capturing genomic interactions spanning hundreds of kilobases. To manage the computational load of such a long sequence, AlphaGenome employs <strong>multi-query attention</strong> (multiple query heads but shared key/value) to reduce memory, and applies <strong>Rotary Positional Embeddings (RoPE)</strong> for encoding positional information over 8192 positions (which correspond to 1,048,576 bp at 128 bp resolution). Additionally, attention logits are stabilized with techniques like <strong>soft clipping</strong> (constraining values to [-5,5]) before softmax. Notably, AlphaGenome introduces a <strong>pairwise interaction bias</strong> in the attention: every second transformer block is preceded by an update to a 2D <strong>pairwise representation</strong> (of size 512×512, representing the 1 Mb region at 2048 bp resolution) that captures spatial contacts between sequence segments. This pairwise matrix (128 channels) is analogous to the approach in AlphaFold, and is used both to produce <strong>3D chromatin contact map</strong> predictions and as an <strong>attention bias</strong> added into the Transformer’s self-attention weights. By injecting this learned pairwise contact bias into the attention layers, the model can more easily learn long-range chromatin loops and interactions while maintaining single-base sensitivity. The final output of the transformer tower is thus a context-enriched sequence embedding (still at 128 bp resolution) along with a pairwise interaction matrix representing coarse chromatin contacts.</p>
<p><strong>Sequence Parallelism for 1 Mb Input</strong>: Handling a 1,048,576 bp input with such a deep model is computationally challenging. AlphaGenome leverages <strong>sequence parallelism</strong> across multiple hardware devices to make this feasible. In practice, the 1 Mb sequence is <strong>split into 8 chunks (~131 kb each)</strong> which are processed in parallel on 8 interconnected TPUv3 cores, with synchronized communication in the transformer layers. This allows true 1 Mb context to be processed with base-pair resolution output, something that would be memory-prohibitive on a single device. The model totals <strong>~450 million parameters</strong> distributed across components (≈20% in encoder conv layers, 28% in transformers, 15% in pairwise/contact blocks, 25% in decoder, 12% in output heads). Despite its scale, the sequence-parallel design enables efficient inference: the final distilled model runs a variant effect prediction in under one second on a modern GPU.</p>
<p><strong>Multi-Scale Outputs and Heads</strong>: AlphaGenome produces predictions at multiple <strong>output resolutions</strong> to suit different assay types. The <strong>task-specific output heads</strong> are linear layers or small networks that take the decoder’s sequence embeddings and produce the final track values. For most genomic tracks (e.g.&nbsp;epigenomic signals, accessibility, basewise expression coverage), the model outputs a <strong>continuous track of predicted signal per base or per small bin</strong>, achieved by upsampling the decoder embeddings back to <strong>1 bp resolution</strong> and applying a linear transformation. Some outputs are naturally lower-resolution (for instance, histone ChIP-seq might be averaged in bins, or 3D contacts are at 2048 bp bins), and these heads use the appropriate latent scale. Importantly, AlphaGenome includes a novel mechanism for <strong>splice junction count prediction</strong>, which is not generated by a single-position linear head. Instead, predicting a junction (connecting a donor and acceptor site) requires pairing two distant sequence positions. AlphaGenome addresses this by a separate junction module that computes an interaction between the <strong>1D embeddings of predicted donor and acceptor sites</strong> to produce a count for that specific exon-exon junction. In essence, it identifies all candidate donor/acceptor pairs from the decoder’s 1 bp resolution embeddings and assigns each a score, enabling prediction of <strong>splice junction read counts</strong> (and even novel exon connections) that standard sequence models could not directly output. This is a <strong>unique architectural feature</strong> of AlphaGenome, allowing it to model splicing outcomes at the level of individual introns (splice junctions) in addition to per-site usage. Overall, by combining convolutional local feature extractors, transformers for global context, and a U-net decoder for high-resolution reconstruction, AlphaGenome’s architecture is able to <strong>capture patterns ranging from transcription factor binding motifs to multi-kilobase enhancer looping, all within one model.</strong></p>
</section>
<section id="training-strategy-two-stage-pre-training-and-distillation" class="level3">
<h3 class="anchored" data-anchor-id="training-strategy-two-stage-pre-training-and-distillation">Training Strategy: Two-Stage Pre-training and Distillation</h3>
<p>Training AlphaGenome to robustly predict genome-wide profiles and variant effects required a carefully designed <strong>two-stage training process</strong>. The authors employed a <strong>pre-training stage</strong> on experimental data followed by a <strong>distillation stage</strong> to produce a single efficient model for variant effect prediction.</p>
<p><strong>Stage 1 – Cross-Validated Pre-training on Experimental Data</strong>: In the first stage, AlphaGenome was trained directly on the vast compendium of experimental genomics data (profiles of chromatin marks, RNA-seq coverage, etc.) using a form of <strong>cross-validation training</strong>. The genome was split into four folds, each comprising 25% of the human (and mouse) reference genome segments. <strong>Fold-specific models</strong> were trained on 3 out of 4 folds (75% of the genome) and validated on the held-out fold. This yields four independent teacher models, each having seen most of the genome but tested on a unique held-out portion. In addition, a separate set of <strong>“all-folds” teacher models</strong> were trained on all available data (100% of the genome intervals) to maximize use of training data. These all-folds models represent what the model can achieve when not holding out any part of the genome, and effectively serve as an ensemble of experts that have seen the full diversity of sequences. Throughout pre-training, <strong>data augmentation</strong> was applied: input 1 Mb sequences were randomly <strong>shifted</strong> or <strong>reverse-complemented</strong> to augment context and reduce positional biases. The model was trained to minimize error between predicted tracks and actual experimental tracks, producing high-fidelity genome track predictors. By the end of this stage, AlphaGenome had learned to accurately predict functional genomics tracks on sequence segments it had never seen (testing on held-out folds) – establishing its strong generalization for <em>genome-wide prediction</em>. Notably, as a fully multimodal model, it was simultaneously learning splicing patterns, gene expression levels, chromatin signals, and more, across thousands of output channels.</p>
<p><strong>Stage 2 – Distillation into a Single Student Model</strong>: While the fold-specific models demonstrated performance, using them for variant effect prediction would require ensembling or making multiple predictions per variant (one for each model). Instead, AlphaGenome’s second stage produces one unified model via <strong>knowledge distillation</strong>. The <strong>all-folds teacher models</strong> (from stage 1) are frozen, and a single <strong>student model</strong> (with the same architecture) is trained to <strong>mimic the teachers’ outputs</strong> on new sequences. In this stage, the student takes augmented input sequences (including simulated variant perturbations) and must predict the outputs that the ensemble of teachers would have produced. Essentially, the student is learning a smoothed, averaged representation of the multiple teacher models. This approach has two key benefits: (1) The student model ends up more robust and accurate on variant effect prediction than any single direct model. Distillation has been shown to <strong>improve robustness and VEP accuracy</strong> in prior work, likely because the student learns to generalize the consensus of many teachers, reducing overfitting to idiosyncrasies. (2) The single student is <strong>computationally efficient</strong>, replacing what would otherwise be an ensemble of 4+ large models. The resulting distilled AlphaGenome can score a variant’s effects on all modalities with <strong>one forward pass</strong> in under one second on modern hardware. This is crucial for practical use in scanning millions of variants. During distillation, <strong>random sequence augmentations and even mutational perturbations</strong> were applied to the input, so the student learns to handle variants implicitly. By learning from the teacher ensemble’s predictions (which have effectively seen the entire genome), the student generalizes well even to variants in novel sequences.</p>
<p><strong>Implications for Variant Effect Prediction</strong>: The two-stage strategy means that <strong>AlphaGenome’s final model is not directly trained on ground-truth variant effect labels</strong>, but rather inherits its variant-scoring ability from the accuracy of the teacher models on reference genome tracks. Because the student sees <strong>mutated sequences</strong> during distillation and must predict the teachers’ outputs for both reference and altered sequences, it effectively learns to <strong>translate sequence changes into output differences</strong>. This distilled model proved to be exceptionally strong in variant effect prediction tasks, outperforming direct training in many cases. The authors note that ensembling across several independently trained models can improve variant effect performance, but their distilled single model <strong>achieves comparable or better accuracy without ensembling</strong>. In summary, the training pipeline first teaches AlphaGenome <em>what</em> patterns to predict (by fitting experimental data), and then teaches it <em>how</em> to efficiently approximate an ensemble of those predictors in one network – yielding a model that is both powerful and practical for scoring variants.</p>
</section>
<section id="comparison-to-enformer-context-length-resolution-and-directional-prediction" class="level3">
<h3 class="anchored" data-anchor-id="comparison-to-enformer-context-length-resolution-and-directional-prediction">Comparison to Enformer: Context Length, Resolution, and Directional Prediction</h3>
<p><strong>Improving on Enformer’s Context vs.&nbsp;Resolution Trade-off</strong>: One of AlphaGenome’s key achievements is combining <strong>long-range genomic context with single-base resolution outputs</strong>, improving upon limitations of the Enformer model. Enformer (Avsec et al., 2021) was an earlier transformer-based model that processed ~200 kb of DNA and predicted epigenomic tracks at a fixed <strong>128 bp output bin size</strong>. This meant Enformer could capture distal enhancers but only produced low-resolution tracks, blurring fine features like splice sites. AlphaGenome extends the input length to <strong>1 Mb</strong> (5× longer) and outputs many tracks at <strong>1 bp resolution</strong>, thanks to its U-Net decoder design. By downsampling and then upsampling with skip connections, AlphaGenome preserves nucleotide-level information despite the large receptive field. In contrast to Enformer’s 128 bp discretization, AlphaGenome can pinpoint effects at individual bases (e.g.&nbsp;exact splice donor positions or transcription start sites) while still modeling contacts and enhancer–promoter interactions hundreds of kilobases away. This effectively eliminates the trade-off: AlphaGenome <strong>captures long-range interactions without sacrificing resolution</strong>. As noted in the paper, previous models like Enformer or its successor Borzoi had to reduce resolution (to 128 bp or even 32 bp bins) to handle &gt;200 kb sequences, missing fine regulatory elements. AlphaGenome’s architecture resolves this by using <strong>sequence parallelism and a multi-scale decoder</strong>, achieving both breadth and detail in predictions. A direct head-to-head benchmark confirmed this improvement: when retrained to predict Enformer’s own track targets, AlphaGenome attained higher accuracy than Enformer even on Enformer’s task, despite using the full 1 Mb input and base-level features. In other words, AlphaGenome can do what Enformer did, only better – plus much more. Figure 1 of the AlphaGenome paper summarizes that across various genome-wide prediction tasks (covering RNA-seq, chromatin marks, etc.), AlphaGenome had <strong>performance gains in the range of +5% to +40%</strong> relative to the best prior models, Enformer included. For instance, it improved Pearson correlation for cell-type-specific gene expression by +17.4% over Borzoi (a model that itself builds on Enformer). These results demonstrate that by addressing Enformer’s limitations – extending context and sharpening resolution – AlphaGenome yields more accurate predictions of genomic function.</p>
<p><strong>Addressing Variant Effect Directionality</strong>: Another notable shortcoming of Enformer was its difficulty in predicting the <strong>direction of variant effects</strong> (i.e.&nbsp;whether a mutation increases or decreases a functional readout). Enformer could predict changes in track intensity, but often struggled to correctly classify the sign of effect, especially for gene expression QTLs. AlphaGenome explicitly tackles this directional prediction problem and shows marked improvements. In evaluations on eQTLs (expression quantitative trait loci), AlphaGenome was able to predict not just the magnitude of expression change but also the <strong>sign (direction) of the </strong> with significantly better accuracy than previous models. For example, compared to Borzoi (the prior state-of-the-art and an improved Enformer-like model), AlphaGenome improved the area under ROC for predicting eQTL effect direction from 0.75 to 0.80 (a substantial +5% increase in classification performance). It also achieved a higher Spearman rho (0.49 vs 0.39) for correlating predicted vs observed effect sizes (magnitudes). These gains indicate that AlphaGenome can more reliably tell if a variant will <strong>up-regulate</strong> or <strong>down-regulate</strong> a gene’s expression, which Enformer and others struggled with. The improvement comes from multiple factors: the <strong>multimodal outputs</strong> (AlphaGenome predicts downstream consequences on many tracks, providing richer clues to infer direction), the <strong>distillation training</strong> (which may smooth out noise and make the model more confident in sign), and possibly architectural changes like basepair-resolution outputs that capture subtle asymmetric effects. As a concrete example, AlphaGenome’s paper highlights a variant near the TAL1 oncogene where Enformer-based scoring had difficulty, but AlphaGenome clearly predicted that the mutation activated an enhancer to increase TAL1 expression. More generally, AlphaGenome was shown to recover far more true positive eQTLs at high precision when requiring correct direction: at 90% predicted sign accuracy, it captured <strong>2× more eQTLs</strong> than the previous model (41% vs 19% of variants). This indicates that researchers can now filter variant hits by predicted direction with much greater confidence. In summary, <strong>AlphaGenome largely overcomes Enformer’s directional limitation</strong> by providing a model that not only predicts the magnitude of molecular changes caused by a variant but also correctly infers the <strong>polarity of the effect</strong> (gain or loss of function) across modalities. This is a critical advancement for variant interpretation, as knowing <em>how</em> a variant perturbs a gene or element (increasing vs decreasing activity) is key to linking variants to phenotypic outcomes.</p>
</section>
</section>
<section id="variant-effect-prediction-across-modalities" class="level2">
<h2 class="anchored" data-anchor-id="variant-effect-prediction-across-modalities">Variant Effect Prediction Across Modalities</h2>
<p>AlphaGenome was evaluated on a comprehensive suite of <strong>26 variant effect prediction (VEP) benchmarks</strong> spanning diverse molecular phenotypes. The model demonstrated high accuracy in predicting variant consequences across <strong>multiple modalities</strong>, including splicing, gene expression, chromatin accessibility, and transcription factor (TF) binding. Here we examine each modality in turn, highlighting AlphaGenome’s performance and novel methodological features like splice junction modeling and composite scoring.</p>
<section id="splicing-variants-unified-splice-site-usage-and-junction-prediction" class="level3">
<h3 class="anchored" data-anchor-id="splicing-variants-unified-splice-site-usage-and-junction-prediction">Splicing Variants: Unified Splice Site, Usage, and Junction Prediction</h3>
<p>One of AlphaGenome’s most innovative aspects is its treatment of <strong>splicing</strong>. Previous models like SpliceAI focused on predicting whether a variant disrupts canonical splice sites (donors/acceptors), and others like Pangolin predicted splice site usage (percent spliced in, PSI) changes, but none directly predicted the formation of new splice junctions. <strong>AlphaGenome is the first system to jointly predict all three levels of splicing outcomes</strong>: (1) the probability of each nucleotide being a splice donor or acceptor, (2) the usage of each splice site (proportion of transcripts using that site), and (3) the presence and read count of specific <strong>splice junctions (introns)</strong> connecting two sites. By integrating these, AlphaGenome provides a holistic view of how a variant will alter splicing patterns. In practice, this means AlphaGenome can detect subtle splicing changes such as <strong>cryptic splice site activation, exon skipping, or novel exon creation</strong>, which are often missed by models that only score nearest splice sites.</p>
<p><strong>Performance on Splicing Benchmarks</strong>: The model’s comprehensive splicing prediction translates into state-of-the-art results on numerous splicing variant benchmarks. AlphaGenome’s authors constructed a <strong>unified splicing variant scorer</strong> that combines the model’s various splicing outputs into a single composite score for a variant. This involves computing separate sub-scores for splice site disruption, changes in splice site usage (ΔPSI), and any new or lost junctions, then summing them into a composite metric. When evaluated on fine-mapped <strong>sQTLs</strong> (splicing QTLs) – variants associated with splicing changes in GTEx – AlphaGenome’s composite scorer achieved the highest accuracy in distinguishing true sQTL variants from negatives. It outperformed prior methods in both “nearby SNP” scenarios (variants within 200 bp of a splice site) and more distant variants affecting splicing up to 10 kb away. Similarly, on a task of predicting <strong>rare splice-disrupting variants</strong> (variants causing aberrant splicing in GTEx outlier samples), AlphaGenome again led both in unsupervised ranking and in a supervised setting.</p>
<p>Notably, in <strong>ClinVar</strong> pathogenicity classification for variants affecting splicing, AlphaGenome’s splicing scores beat the previous best method (Pangolin) in every category. For example, for deep intronic or synonymous variants that sometimes create cryptic splice sites, AlphaGenome achieved an auPRC of 0.66 vs 0.64 by Pangolin. In the “splice region” category (variants near exon-intron junctions), it scored 0.57 auPRC vs 0.55 for Pangolin, and even for missense variants (where splicing changes are an off-target effect) it edged out the competition (0.18 vs 0.16). The only benchmark where AlphaGenome did not rank first was a high-throughput splicing reporter assay (MFASS) for which Pangolin slightly exceeded it (auPRC 0.54 vs 0.51). Even there, AlphaGenome still outperformed other tools like SpliceAI and DeltaSplice (each 0.49). Interestingly, the authors found that the <strong>splice junction-specific sub-score alone</strong> (ignoring site disruption scores) was extremely powerful: it outperformed all prior methods on 5 of 7 benchmarks by itself. This underscores the value of <strong>explicit junction prediction</strong> – by modeling the creation or loss of specific exon-exon links, AlphaGenome captures effects that purely site-based models might miss. Overall, AlphaGenome was declared a “state-of-the-art splicing VEP model”, achieving SOTA on 6 of 7 tests. The rich splicing output not only improves accuracy but also provides mechanistic insight. For example, AlphaGenome correctly predicted a known case of <strong>exon skipping</strong>: a 4 bp deletion in the <em>DLG1</em> gene that causes an exon to be skipped in arterial tissue. The model’s predictions showed reduced usage of the exon’s splice site, disappearance of junctions that include that exon, appearance of a junction skipping over it, and loss of RNA-seq coverage for that exon – precisely matching the experimental observation. In another example, it captured a <strong>novel splice junction</strong> created by a variant in the <em>COL6A2</em> gene (Aorta tissue), which led to an extended exon; AlphaGenome’s junction and coverage predictions mirrored the GTEx RNA-seq evidence of that new splicing event. These case studies highlight how AlphaGenome’s fine-grained splicing predictions can pinpoint the exact nature of splicing alterations caused by variants, an ability that was lacking in earlier general models.</p>
</section>
<section id="gene-expression-and-regulatory-variants-eqtls-and-enhancer-effects" class="level3">
<h3 class="anchored" data-anchor-id="gene-expression-and-regulatory-variants-eqtls-and-enhancer-effects">Gene Expression and Regulatory Variants: eQTLs and Enhancer Effects</h3>
<p>For <strong>gene expression</strong> phenotypes, AlphaGenome also demonstrated strong performance in predicting variant impacts. It was tested on tasks involving expression quantitative trait loci (<strong>eQTLs</strong>), which are variants associated with gene expression changes in particular tissues, and on enhancer perturbation experiments, among others.</p>
<p><strong>eQTL Effect Size and Direction</strong>: Using fine-mapped GTEx eQTLs as a benchmark, AlphaGenome was compared to previous models (notably Borzoi ensemble and Enformer) for predicting how a variant affects gene expression. The model uses a custom variant scoring approach for eQTLs, where it aggregates predicted changes in relevant expression tracks (like RNA-seq coverage or transcription initiation at a gene’s promoter) into a single score per variant-gene pair. AlphaGenome achieved substantially higher correlation with the actual measured eQTL effect sizes (the “beta coefficients” from statistical fine-mapping) than prior methods. Its average Spearman correlation across tissues was 0.49, versus 0.39 for the previous best (Borzoi). Moreover, as discussed in the Enformer comparison, AlphaGenome greatly improved the <strong>sign prediction</strong> for eQTLs – an auROC of 0.80 for classifying an allele as up- vs down-regulating, compared to ~0.75 before. These improvements were consistent across most tissues, across both SNPs and indel variants, and even for eQTLs far from the target gene’s transcription start site. The practical effect is that researchers can take AlphaGenome’s score and much more confidently identify not just which variant-gene pairs are likely causal, but also predict whether the variant increases or decreases expression of that gene. In a simulated “GWAS interpretation” exercise, the authors showed that by setting a high threshold on the AlphaGenome eQTL sign score (calibrated to 80% precision), they could assign a reliable direction of effect to at least one candidate variant in <strong>49% of GWAS loci</strong> tested – compared to only 11% using a conservative statistical colocalization method. This suggests AlphaGenome can add significant value in post-GWAS analysis by indicating which risk allele is likely gain-of-function vs loss-of-function for nearby genes, thereby generating hypotheses about disease mechanisms.</p>
<p><strong>Enhancer–Gene Linking</strong>: Another gene expression related task is predicting which enhancers regulate which genes (enhancer-gene links). AlphaGenome was evaluated zero-shot on a CRISPR interference (CRISPRi) perturbation dataset from the ENCODE consortium, where enhancers were experimentally silenced and the effect on gene expression was measured. AlphaGenome’s variant scoring for this task would involve simulating the effect of an “enhancer deletion” (perhaps by dropping a sequence segment or altering it) and seeing if the target gene’s predicted expression changes. In identifying true enhancer-gene pairs, AlphaGenome outperformed Borzoi, especially for enhancers located &gt;10 kb from the gene promoter. In other words, it was better at linking distal enhancers to their target genes, presumably because its 1 Mb context and attention mechanism can capture those long-range interactions. Both models still had limitations (they underestimated the effect magnitude of far enhancers, per the authors), but AlphaGenome’s advantage suggests it could be a useful tool for prioritizing likely enhancer target genes, an important aspect of non-coding variant interpretation. Additionally, AlphaGenome was tested on <strong>alternative polyadenylation (APA)</strong> variant effects (since APA is listed as a modality). While details weren’t given in the excerpt, the model likely predicts usage of polyA sites and was benchmarked on APA QTLs or reporter assays; given the overall success, one can infer it performed strongly there as well (the paper noted SOTA on 24/26 variant tasks, so most likely including APA).</p>
<p><strong>Chromatin Accessibility and TF Binding Variants</strong>: AlphaGenome covers chromatin readouts such as open chromatin (DNase-seq, ATAC-seq) and transcription factor ChIP-seq profiles, and these were also included in variant effect tests. For <strong>chromatin accessibility</strong>, a typical benchmark is to predict the effect of a variant on open chromatin, e.g.&nbsp;in ATAC-seq peaks or DNase sensitivity, often framed as QTL tasks (caQTLs) or allele-specific accessibility. AlphaGenome indeed was evaluated on multiple such datasets – the paper mentions <em>five directionality benchmarks and three causality benchmarks</em> for accessibility variants. In all of them, AlphaGenome outperformed the state-of-the-art single-modality models like ChromBPNet or DeltaSVM. In aggregate, AlphaGenome had an <strong>average +8.0% relative improvement</strong> in predicting accessibility QTL effect direction compared to ChromBPNet. This means it was better at telling if a variant makes a chromatin site more open or more closed. Similarly, for identifying causal variants among many in linkage (the “causality” task, distinguishing the true causal variant from nearby neutrals in accessibility QTL studies), AlphaGenome matched or slightly exceeded prior best performance (the text noted it was comparable to Borzoi on that, but a supervised model using AlphaGenome’s multi-modal scores boosted performance significantly above Borzoi). The <strong>multi-modal nature</strong> is key here: the authors showed that using features from <em>multiple modalities</em> of AlphaGenome (e.g.&nbsp;combining its predicted effects on chromatin, expression, and splicing) in a random forest improved causality prediction AUROC from 0.68 to 0.75 – notably higher than using only RNA-seq features or any single source. This demonstrates that AlphaGenome’s ability to simultaneously score a variant’s impact on many layers of gene regulation can be harnessed to better pinpoint causal non-coding variants than looking at one modality alone.</p>
<p>For <strong>transcription factor binding</strong> variants, tasks likely included predicting if a variant disrupts a TF binding motif and thus changes ChIP-seq signal, or high-throughput reporter assays measuring motif activity (like MPRA data for motif variants). While specifics aren’t detailed in the excerpt, AlphaGenome presumably did well: for instance, it outperformed a motif-focused model in at least some TF benchmarks. The model Sei (and a newer one, Orca) had included TF binding predictions, but AlphaGenome with its greater context and resolution likely captured cases where a distal element influences TF binding. We know from the introduction that AlphaGenome outperformed <strong>ChromBPNet</strong> (a base-resolution accessibility/TF model) on profile predictions by 8–19%, so it stands to reason it would translate to variant effect improvements in those areas as well.</p>
<p><strong>Composite Variant Scoring</strong>: Across these modalities, AlphaGenome often uses <strong>composite scores</strong> that aggregate its multi-modal predictions into a single variant impact metric for a given task. We saw this in splicing (summing splice site + junction changes) and it’s also applied in other contexts. For example, prior models like Enformer defined a “variant score” by summing predicted changes across relevant tracks (e.g.&nbsp;difference in CAGE signal + difference in DNase signal as a combined regulatory score). AlphaGenome can do the same but with potentially more tracks. The supplementary information notes that when using the exact same composite features as Enformer or Borzoi (like DNase + CAGE, or DNase + histone + RNA), AlphaGenome’s predictions <strong>generally outperformed Enformer and Borzoi</strong> for all such feature combinations. This implies that even if one uses a simplified scoring scheme mimicking older models, AlphaGenome’s raw predictions are more accurate, leading to better variant prioritization. But one can also exploit its full breadth: the paper’s Fig. 6 (cross-modal variant interpretation) likely shows an example where a variant near the <em>TAL1</em> gene was simultaneously flagged by AlphaGenome as creating a new TF binding site, increasing accessibility, and boosting gene expression – a combination that explained how a non-coding mutation led to oncogene activation. Such <strong>integrated interpretations</strong> are a novel strength of AlphaGenome: because it predicts so many modalities at once, one can trace the cascade of effects (e.g., a variant increases chromatin accessibility and H3K27ac at an enhancer, which increases CAGE signal at a promoter, which increases RNA-seq for a gene, etc.). This is extremely useful for understanding complex variant mechanisms and also suggests rich features for integration with other modeling approaches.</p>
</section>
</section>
<section id="cross-modality-integration-and-future-directions-with-genomic-language-models" class="level2">
<h2 class="anchored" data-anchor-id="cross-modality-integration-and-future-directions-with-genomic-language-models">Cross-Modality Integration and Future Directions with Genomic Language Models</h2>
<p>AlphaGenome provides a powerful platform for predicting molecular phenotypes from DNA sequence. An exciting next step is to consider how its predictions could be integrated with <strong>genomic language models</strong> – large-scale sequence or gene models like Geneformer, GenSLMs, DNABERT and Evo 2 – to tackle higher-level tasks. While AlphaGenome is a supervised, mechanistic model of genomic function, gene language models are typically trained unsupervised to capture the statistical patterns or “grammar” of sequences or gene networks. Combining these approaches could yield synergistic benefits for tasks such as variant prioritization, phenotype prediction, and genome annotation.</p>
<p><strong>Complementary Strengths of AlphaGenome and Language Models</strong>: A recent perspective highlighted that there are two broad classes of variant effect predictors: <em>activity models</em> like Enformer/AlphaGenome that predict specific molecular activities, and <em>fitness models</em> like genomic language models that infer overall variant deleteriousness from sequence context. These approaches address different angles – AlphaGenome nominates a <strong>mechanism and context</strong> (e.g., “this variant likely disrupts a liver enhancer of gene X, lowering gene expression”), whereas a genomic LLM (like a GenSLM) might provide an <strong>evolutionary or holistic fitness score for the variant based on learned sequence distribution</strong>. By combining them, one can get both the “how” and the “how bad” of a variant’s effect. For instance, if AlphaGenome predicts a variant greatly reduces <em>TP53</em> gene expression, and a genomic language model also assigns that variant a low likelihood (highly deleterious) score, together they make a strong case for prioritization – AlphaGenome explains the regulatory mechanism and the language model concurs that such a change is atypical in evolution and likely harmful. Conversely, an LLM might flag a variant in a gene that is highly dosage-sensitive (something AlphaGenome doesn’t know from sequence alone), helping distinguish which of two expression-changing variants has bigger phenotypic impact. In short, AlphaGenome’s <strong>mechanistic predictions</strong> and language models’ <strong>contextual knowledge</strong> could be integrated to improve identification of truly causal and medically relevant variants.</p>
<section id="example-applications" class="level3">
<h3 class="anchored" data-anchor-id="example-applications">Example Applications</h3>
<p><strong>Variant Prioritization in Clinical Genomics</strong>: In genome interpretation (e.g.&nbsp;rare disease diagnostics or non-coding GWAS hits), one could use AlphaGenome to generate a feature set for each variant – predicted changes in splice junctions, gene expression, chromatin states, etc. – and feed these as inputs to a model that also leverages sequence embeddings from a genomic language model (like DNABERT or a GenSLM). A language model like DNABERT encodes local sequence motif context in an unsupervised way, potentially capturing subtle sequence features or evolutionary signals. Combining this with AlphaGenome’s output features could train a powerful classifier to distinguish pathogenic variants from benign. For example, a <strong>composite model</strong> might take AlphaGenome’s predicted impact on gene Y’s expression and splicing, plus a DNABERT-derived embedding of the variant’s sequence neighborhood (reflecting motif disruptions or conservation learned implicitly), to decide if the variant is likely disease-causing. The language model provides an independent signal of sequence “weirdness” or conservation (e.g., log-likelihood ratio of reference vs alternate allele as in some gLM fitness scores), complementing AlphaGenome’s functional readouts. This could be especially useful for variants where AlphaGenome indicates a moderate effect – the language model might help prioritize those that hit crucial genes or sequences that are ultraconserved.</p>
<p><strong>Phenotype Prediction and Network Modeling</strong>: Gene-focused language models like Geneformer (Theodoris et al., 2023) are trained on large single-cell gene expression datasets to model gene regulatory networks. Geneformer can predict how activating or inhibiting one gene may affect others in a cell’s network (it’s a context-aware transformer that learned gene co-expression and regulatory relationships). AlphaGenome could interface with such models by providing the initial effect of a variant on gene expression, which Geneformer can then propagate through a network. For instance, if AlphaGenome predicts that a non-coding variant decreases the expression of a transcription factor gene in heart tissue, one could input this perturbation into Geneformer to predict downstream changes in cardiac gene networks and phenotypic pathways (since Geneformer has learned which genes tend to respond to which in heart cells). This would enable a more <strong>holistic phenotype prediction</strong>: AlphaGenome tells us the direct effect of the variant on immediate molecular functions (gene X down-regulated, etc.), and the gene network model predicts the secondary effects (gene X’s targets also change, leading to a pathway dysregulation). Such integration could help answer, for example, “Given this variant’s predicted regulatory effects, what higher-order cellular processes or disease phenotypes might be impacted?” – a step towards bridging genotype to phenotype. In practice, one could imagine a pipeline where AlphaGenome scores all variants in a person’s genome, identifies those that markedly affect important genes or pathways, then a model like Geneformer (or its variants) evaluates which of those could cause the patient’s observed phenotype by simulating gene network perturbations. This cross-talk between sequence-level models and expression-level models could greatly enhance <strong>variant prioritization in complex diseases</strong>.</p>
<p><strong>Genome Annotation and Feature Augmentation</strong>: Large genomic language models (for DNA) such as GenSLMs and Evo 2 have been trained on entire genomes (e.g., viral or bacterial genomes) to learn sequence representations that encode functional regions and evolutionary constraints. One could use AlphaGenome’s outputs to enrich genome annotations for these models. For example, GenSLM embeddings can classify genomic windows by type (promoter, enhancer, neutral, etc.) to some extent. AlphaGenome’s predictions (like “this 1 Mb region has strong H3K27ac and ATAC peaks here and here, and a CAGE peak at this position”) could be used as additional channels or prompts to a language model to improve its understanding. A <strong>hybrid model</strong> might feed sequence along with AlphaGenome-predicted track features into a transformer that then performs tasks like enhancer classification or gene–enhancer linking. Essentially, AlphaGenome could act as an automatic annotation layer, providing inputs that guide the language model to focus on biologically relevant signals. This could also work in reverse: a language model could generate hypothetical regulatory sequences (as some generative models do for promoter design), and AlphaGenome could evaluate those designs by predicting if they indeed produce the desired regulatory outputs (high expression of a target gene, etc.). This pairing combines the <strong>creative generation</strong> ability of gLMs with the <strong>evaluatio</strong> ability of AlphaGenome in a design loop, for applications like synthetic biology or gene therapy target optimization. In genome annotation projects, one could imagine using an LLM (like GPT-style model) to read AlphaGenome’s predicted patterns and then produce natural-language descriptions – e.g., “AlphaGenome predicts an enhancer in this locus that likely regulates FOXP2 (open chromatin and H3K27ac present, and eQTL signals to FOXP2).” This would greatly aid interpretability, though it requires the language model to be trained or prompted to interpret the numeric outputs.</p>
<p>In summary, <strong>AlphaGenome’s rich predictive features could serve as high-value inputs or adjuncts to foundation models of the genome</strong>. By providing explicit mechanistic signals (which base, which gene, how much effect), AlphaGenome can ground the sometimes abstract embeddings from language models in concrete biology. Conversely, genomic language models can supply broader context – evolutionary, network-level, or literature-driven knowledge – that is outside the scope of AlphaGenome’s training. The combination could enhance tasks like variant prioritization (filtering variants by both functional impact and known gene importance), phenotype prediction (connecting molecular effects to clinical outcomes using learned gene network behavior), and genome annotation (using functional predictions to inform or validate LLM-derived insights). As a recent review noted, <strong>activity predictors and genomic LLMs are complementary</strong>, and leveraging both may be the key to interpreting variants that induce similar molecular changes but have different organism-level consequences。</p>
</section>
</section>
<section id="authors-reflections-and-open-issues" class="level2">
<h2 class="anchored" data-anchor-id="authors-reflections-and-open-issues">Authors’ Reflections and Open Issues</h2>
<p>The creators of AlphaGenome are candid about many of these limitations. In the preprint and official blog, they stress that <strong>AlphaGenome is a significant step forward but not a solved game</strong>. They explicitly list ongoing challenges such as capturing very distant enhancers (&gt;100 kb), improving cell/tissue-specific accuracy, expanding to other species, and bridging the gap from molecular effects to complex traits. They did not attempt personal genome interpretation or clinical diagnosis with AlphaGenome, acknowledging that those remain difficult for AI models and were outside their project’s scope. The team encourages experimental validation of predictions and is actively seeking community feedback on where the model fails. They have also outlined <strong>future improvements</strong>: plans include incorporating single-cell data for finer cell specificity, extending to additional species, and even integrating developmental or environmental context down the line. This aligns with external critiques that noted the absence of such data in the current model and the importance of including it going forward. Another point of critique has been the accessibility of the model – DeepMind’s choice to release AlphaGenome via API (with code/weights to follow later) drew some community ire given the push for open science. The authors mitigated this by committing to open-source release upon publication, and emphasizing that AlphaGenome is meant to be a foundation others can fine-tune and build on. Nonetheless, until full release, some researchers remain frustrated that an open benchmark against models like Evo 2 or other community models isn’t possible yet.</p>
<p>In related evaluations and commentary, experts have lauded AlphaGenome’s achievement (1 Mb context and multi-modal prediction) but also note it as an expected next step rather than a complete solution. There is recognition that “there’s so much biology for which we simply don’t have the data to learn from” even with such models – meaning limitations often arise not just from the model design but from gaps in training data (e.g., unmeasured cell types, conditions, or multi-omic interactions). A critical perspective is that AlphaGenome, like its predecessors, will only be as good as the data available. If certain regulatory logic isn’t present in the training datasets, the model can’t invent it. Thus, one open issue is the need for more and better data (e.g.&nbsp;perturbation experiments to validate causal variant effects, or data from diverse human populations to capture ancestry-specific regulatory variants). The authors of AlphaGenome seem aware of this, as they encourage combining the model’s outputs with other evidence and plan to extend training data in future iterations.</p>
<p>In conclusion, AlphaGenome’s potential limitations span multiple dimensions: methodologically, it’s a complex distilled model with finite attention span and black-box internals; in benchmarking, it excels on known tasks but hasn’t proven itself on truly novel or rare-case scenarios; in deployment, it demands heavy compute and careful use (though an efficient API helps); in biological scope, it doesn’t yet cover every species, cell type or polygenic effect; and compared to broad foundation models, it sacrifices universality and generative flexibility for focused accuracy. These shortcomings are actively acknowledged by the authors and the community, and they point towards clear directions for future research. We can expect subsequent versions or related models to address some of these – for example, by integrating single-cell and cross-species data to broaden scope, adopting new attention mechanisms to further extend long-range capture, or leveraging foundation model insights to make AlphaGenome more general. In the meantime, researchers using AlphaGenome should be mindful of its current boundaries: <strong>it is a powerful, state-of-the-art tool</strong> – but not a magic bullet – and its predictions should be interpreted in context, with an understanding of what might lie outside its view.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>