<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Adrian">
<meta name="dcterms.date" content="2025-08-02">

<title>AlphaGenome Evolution: Advancing Regulatory Variant Prediction and Genomic Modeling – Adrian’s Genomics Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e2ec580592f0bca8c79b521847304919.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Adrian’s Genomics Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog-posts/"> 
<span class="menu-text">Blog Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a>
  <ul class="collapse">
  <li><a href="#model-architecture-u-net-design-with-transformers-and-multi-resolution-output" id="toc-model-architecture-u-net-design-with-transformers-and-multi-resolution-output" class="nav-link" data-scroll-target="#model-architecture-u-net-design-with-transformers-and-multi-resolution-output">Model Architecture: U-Net Design with Transformers and Multi-Resolution Output</a></li>
  <li><a href="#training-strategy-two-stage-pre-training-and-distillation" id="toc-training-strategy-two-stage-pre-training-and-distillation" class="nav-link" data-scroll-target="#training-strategy-two-stage-pre-training-and-distillation">Training Strategy: Two-Stage Pre-training and Distillation</a></li>
  <li><a href="#comparison-to-enformer-context-length-resolution-and-directional-prediction" id="toc-comparison-to-enformer-context-length-resolution-and-directional-prediction" class="nav-link" data-scroll-target="#comparison-to-enformer-context-length-resolution-and-directional-prediction">Comparison to Enformer: Context Length, Resolution, and Directional Prediction</a></li>
  </ul></li>
  <li><a href="#variant-effect-prediction-across-modalities" id="toc-variant-effect-prediction-across-modalities" class="nav-link" data-scroll-target="#variant-effect-prediction-across-modalities">Variant Effect Prediction Across Modalities</a>
  <ul class="collapse">
  <li><a href="#splicing-variants-unified-splice-site-usage-and-junction-prediction" id="toc-splicing-variants-unified-splice-site-usage-and-junction-prediction" class="nav-link" data-scroll-target="#splicing-variants-unified-splice-site-usage-and-junction-prediction">Splicing Variants: Unified Splice Site, Usage, and Junction Prediction</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">AlphaGenome Evolution: Advancing Regulatory Variant Prediction and Genomic Modeling</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Genomics</div>
    <div class="quarto-category">Generative Modeling</div>
    <div class="quarto-category">Bioinformatics</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Adrian </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 2, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>AlphaGenome is a deep learning model that processes 1 megabase (Mb) of DNA sequence to predict a broad range of functional genomic outputs at high resolution. Developed by Google DeepMind, AlphaGenome unifies multimodal genomic prediction, long-range sequence context, and single base-pair resolution into one framework. It generates 5,930 human (or 1,128 mouse) genome tracks covering 11 data modalities – including gene expression (RNA-seq, CAGE, PRO-cap), splicing (splice sites, splice site usage, splice junctions), chromatin accessibility (DNase, ATAC-seq), histone marks, transcription factor binding, and 3D chromatin contacts. Trained jointly on human and mouse genomes, AlphaGenome achieves or exceeds state-of-the-art performance on the vast majority of benchmarks, matching or outperforming the best available models on 24 out of 26 variant effect prediction tasks. In doing so, it addresses longstanding trade-offs in genome modeling by capturing both distal regulatory context and nucleotide-level detail, enabling more accurate predictions of how genetic variants influence gene regulation. This report provides a detailed overview of AlphaGenome’s methodology – including its architecture, training strategy, improvements over the earlier Enformer model, variant effect prediction performance across multiple modalities, and speculations on integrating AlphaGenome with genomic language models.</p>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<section id="model-architecture-u-net-design-with-transformers-and-multi-resolution-output" class="level3">
<h3 class="anchored" data-anchor-id="model-architecture-u-net-design-with-transformers-and-multi-resolution-output">Model Architecture: U-Net Design with Transformers and Multi-Resolution Output</h3>
<p>U-Net–style Encoder–Decoder: AlphaGenome’s architecture follows a U-Net inspired design, consisting of an encoder that progressively downsamples the input sequence, a “Transformer Tower” that integrates long-range information, and a decoder that upsamples back to high resolution outputs. The encoder–decoder structure is similar to those in image segmentation (U-Net) but adapted for 1D genomic sequences. The sequence encoder uses multiple convolutional blocks and pooling to reduce the sequence length while increasing channel depth, extracting hierarchical features at increasing scales. Starting from 1 bp resolution with 768 channels, the encoder downsamples through 7 stages (with max-pooling by 2 at each stage) to a final 128 bp resolution latent representation with 1536 channels. Convolutional filters capture local sequence motifs (e.g.&nbsp;transcription factor binding sites, splice signals) needed for base-level precision. Residual connections (“skip” connections) from the encoder layers are carried into the decoder, as in U-Net, to preserve fine-grained spatial information. The sequence decoder upsamples the latent representation back toward higher resolutions, merging with encoder skip features to output predictions at multiple scales (including single-nucleotide resolution for certain tracks). This multi-resolution design allows AlphaGenome to output different genomic tracks at the appropriate resolution for each assay – for example, base-pair resolution for splice site usage or transcription start sites, and binned resolution for broader signals like contacts.</p>
<p>Transformer Layers for Long-Range Context: Between encoder and decoder, AlphaGenome inserts a stack of Transformer blocks (the “Transformer Tower”) operating on the 128 bp-resolution encoded sequence. Nine transformer layers model coarse but long-range dependencies across the entire 1 Mb input, such as distal enhancer–promoter interactions or coordinated chromatin state changes. These transformers use multi-head self-attention to allow any position in the 1 Mb sequence to attend to any other, capturing genomic interactions spanning hundreds of kilobases. To manage the computational load of such a long sequence, AlphaGenome employs multi-query attention (multiple query heads but shared key/value) to reduce memory, and applies Rotary Positional Embeddings (RoPE) for encoding positional information over 8192 positions (which correspond to 1,048,576 bp at 128 bp resolution). Additionally, attention logits are stabilized with techniques like soft clipping (constraining values to [-5,5]) before softmax. Notably, AlphaGenome introduces a pairwise interaction bias in the attention: every second transformer block is preceded by an update to a 2D pairwise representation (of size 512×512, representing the 1 Mb region at 2048 bp resolution) that captures spatial contacts between sequence segments. This pairwise matrix (128 channels) is analogous to the approach in AlphaFold, and is used both to produce 3D chromatin contact map predictions and as an attention bias added into the Transformer’s self-attention weights. By injecting this learned pairwise contact bias into the attention layers, the model can more easily learn long-range chromatin loops and interactions while maintaining single-base sensitivity. The final output of the transformer tower is thus a context-enriched sequence embedding (still at 128 bp resolution) along with a pairwise interaction matrix representing coarse chromatin contacts.</p>
<p>Sequence Parallelism for 1 Mb Input: Handling a 1,048,576 bp input with such a deep model is computationally challenging. AlphaGenome leverages sequence parallelism across multiple hardware devices to make this feasible. In practice, the 1 Mb sequence is split into 8 chunks (~131 kb each) which are processed in parallel on 8 interconnected TPUv3 cores, with synchronized communication in the transformer layers. This allows true 1 Mb context to be processed with base-pair resolution output, something that would be memory-prohibitive on a single device. The model totals ~450 million parameters distributed across components (≈20% in encoder conv layers, 28% in transformers, 15% in pairwise/contact blocks, 25% in decoder, 12% in output heads). Despite its scale, the sequence-parallel design enables efficient inference: the final distilled model runs a variant effect prediction in under one second on a modern GPU.</p>
<p>Multi-Scale Outputs and Heads: AlphaGenome produces predictions at multiple output resolutions to suit different assay types. The task-specific output heads are linear layers or small networks that take the decoder’s sequence embeddings and produce the final track values. For most genomic tracks (e.g.&nbsp;epigenomic signals, accessibility, basewise expression coverage), the model outputs a continuous track of predicted signal per base or per small bin, achieved by upsampling the decoder embeddings back to 1 bp resolution and applying a linear transformation. Some outputs are naturally lower-resolution (for instance, histone ChIP-seq might be averaged in bins, or 3D contacts are at 2048 bp bins), and these heads use the appropriate latent scale. Importantly, AlphaGenome includes a novel mechanism for splice junction count prediction, which is not generated by a single-position linear head. Instead, predicting a junction (connecting a donor and acceptor site) requires pairing two distant sequence positions. AlphaGenome addresses this by a separate junction module that computes an interaction between the 1D embeddings of predicted donor and acceptor sites to produce a count for that specific exon-exon junction. In essence, it identifies all candidate donor/acceptor pairs from the decoder’s 1 bp resolution embeddings and assigns each a score, enabling prediction of splice junction read counts (and even novel exon connections) that standard sequence models could not directly output. This is a unique architectural feature of AlphaGenome, allowing it to model splicing outcomes at the level of individual introns (splice junctions) in addition to per-site usage. Overall, by combining convolutional local feature extractors, transformers for global context, and a U-net decoder for high-resolution reconstruction, AlphaGenome’s architecture is able to capture patterns ranging from transcription factor binding motifs to multi-kilobase enhancer looping, all within one model.</p>
</section>
<section id="training-strategy-two-stage-pre-training-and-distillation" class="level3">
<h3 class="anchored" data-anchor-id="training-strategy-two-stage-pre-training-and-distillation">Training Strategy: Two-Stage Pre-training and Distillation</h3>
<p>Training AlphaGenome to robustly predict genome-wide profiles and variant effects required a carefully designed two-stage training process. The authors employed a pre-training stage on experimental data followed by a distillation stage to produce a single efficient model for variant effect prediction.</p>
<p>Stage 1 – Cross-Validated Pre-training on Experimental Data: In the first stage, AlphaGenome was trained directly on the vast compendium of experimental genomics data (profiles of chromatin marks, RNA-seq coverage, etc.) using a form of cross-validation training. The genome was split into four folds, each comprising 25% of the human (and mouse) reference genome segments. Fold-specific models were trained on 3 out of 4 folds (75% of the genome) and validated on the held-out fold. This yields four independent teacher models, each having seen most of the genome but tested on a unique held-out portion. In addition, a separate set of “all-folds” teacher models were trained on all available data (100% of the genome intervals) to maximize use of training data. These all-folds models represent what the model can achieve when not holding out any part of the genome, and effectively serve as an ensemble of experts that have seen the full diversity of sequences. Throughout pre-training, data augmentation was applied: input 1 Mb sequences were randomly shifted or reverse-complemented to augment context and reduce positional biases. The model was trained to minimize error between predicted tracks and actual experimental tracks, producing high-fidelity genome track predictors. By the end of this stage, AlphaGenome had learned to accurately predict functional genomics tracks on sequence segments it had never seen (testing on held-out folds) – establishing its strong generalization for genome-wide prediction. Notably, as a fully multimodal model, it was simultaneously learning splicing patterns, gene expression levels, chromatin signals, and more, across thousands of output channels.</p>
<p>Stage 2 – Distillation into a Single Student Model: While the fold-specific models demonstrated performance, using them for variant effect prediction would require ensembling or making multiple predictions per variant (one for each model). Instead, AlphaGenome’s second stage produces one unified model via knowledge distillation. The all-folds teacher models (from stage 1) are frozen, and a single student model (with the same architecture) is trained to mimic the teachers’ outputs on new sequences. In this stage, the student takes augmented input sequences (including simulated variant perturbations) and must predict the outputs that the ensemble of teachers would have produced. Essentially, the student is learning a smoothed, averaged representation of the multiple teacher models. This approach has two key benefits: (1) The student model ends up more robust and accurate on variant effect prediction than any single direct model. Distillation has been shown to improve robustness and VEP accuracy in prior work, likely because the student learns to generalize the consensus of many teachers, reducing overfitting to idiosyncrasies. (2) The single student is computationally efficient, replacing what would otherwise be an ensemble of 4+ large models. The resulting distilled AlphaGenome can score a variant’s effects on all modalities with one forward pass in under one second on modern hardware. This is crucial for practical use in scanning millions of variants. During distillation, random sequence augmentations and even mutational perturbations were applied to the input, so the student learns to handle variants implicitly. By learning from the teacher ensemble’s predictions (which have effectively seen the entire genome), the student generalizes well even to variants in novel sequences.</p>
<p>Implications for Variant Effect Prediction: The two-stage strategy means that AlphaGenome’s final model is not directly trained on ground-truth variant effect labels, but rather inherits its variant-scoring ability from the accuracy of the teacher models on reference genome tracks. Because the student sees mutated sequences during distillation and must predict the teachers’ outputs for both reference and altered sequences, it effectively learns to translate sequence changes into output differences. This distilled model proved to be exceptionally strong in variant effect prediction tasks, outperforming direct training in many cases. The authors note that ensembling across several independently trained models can improve variant effect performance, but their distilled single model achieves comparable or better accuracy without ensembling. In summary, the training pipeline first teaches AlphaGenome what patterns to predict (by fitting experimental data), and then teaches it how to efficiently approximate an ensemble of those predictors in one network – yielding a model that is both powerful and practical for scoring variants.</p>
</section>
<section id="comparison-to-enformer-context-length-resolution-and-directional-prediction" class="level3">
<h3 class="anchored" data-anchor-id="comparison-to-enformer-context-length-resolution-and-directional-prediction">Comparison to Enformer: Context Length, Resolution, and Directional Prediction</h3>
<p>Improving on Enformer’s Context vs.&nbsp;Resolution Trade-off: One of AlphaGenome’s key achievements is combining long-range genomic context with single-base resolution outputs, improving upon limitations of the Enformer model. Enformer (Avsec et al., 2021) was an earlier transformer-based model that processed ~200 kb of DNA and predicted epigenomic tracks at a fixed 128 bp output bin size. This meant Enformer could capture distal enhancers but only produced low-resolution tracks, blurring fine features like splice sites. AlphaGenome extends the input length to 1 Mb (5× longer) and outputs many tracks at 1 bp resolution, thanks to its U-Net decoder design. By downsampling and then upsampling with skip connections, AlphaGenome preserves nucleotide-level information despite the large receptive field. In contrast to Enformer’s 128 bp discretization, AlphaGenome can pinpoint effects at individual bases (e.g.&nbsp;exact splice donor positions or transcription start sites) while still modeling contacts and enhancer–promoter interactions hundreds of kilobases away. This effectively eliminates the trade-off: AlphaGenome captures long-range interactions without sacrificing resolution. As noted in the paper, previous models like Enformer or its successor Borzoi had to reduce resolution (to 128 bp or even 32 bp bins) to handle &gt;200 kb sequences, missing fine regulatory elements. AlphaGenome’s architecture resolves this by using sequence parallelism and a multi-scale decoder, achieving both breadth and detail in predictions. A direct head-to-head benchmark confirmed this improvement: when retrained to predict Enformer’s own track targets, AlphaGenome attained higher accuracy than Enformer even on Enformer’s task, despite using the full 1 Mb input and base-level features. In other words, AlphaGenome can do what Enformer did, only better – plus much more. Figure 1 of the AlphaGenome paper summarizes that across various genome-wide prediction tasks (covering RNA-seq, chromatin marks, etc.), AlphaGenome had performance gains in the range of +5% to +40% relative to the best prior models, Enformer included. For instance, it improved Pearson correlation for cell-type-specific gene expression by +17.4% over Borzoi (a model that itself builds on Enformer). These results demonstrate that by addressing Enformer’s limitations – extending context and sharpening resolution – AlphaGenome yields more accurate predictions of genomic function.</p>
<p>Addressing Variant Effect Directionality: Another notable shortcoming of Enformer was its difficulty in predicting the direction of variant effects (i.e.&nbsp;whether a mutation increases or decreases a functional readout). Enformer could predict changes in track intensity, but often struggled to correctly classify the sign of effect, especially for gene expression QTLs. AlphaGenome explicitly tackles this directional prediction problem and shows marked improvements. In evaluations on eQTLs (expression quantitative trait loci), AlphaGenome was able to predict not just the magnitude of expression change but also the sign (direction) of the effect with significantly better accuracy than previous models. For example, compared to Borzoi (the prior state-of-the-art and an improved Enformer-like model), AlphaGenome improved the area under ROC for predicting eQTL effect direction from 0.75 to 0.80 (a substantial +5% increase in classification performance). It also achieved a higher Spearman rho (0.49 vs 0.39) for correlating predicted vs observed effect sizes (magnitudes). These gains indicate that AlphaGenome can more reliably tell if a variant will up-regulate or down-regulate a gene’s expression, which Enformer and others struggled with. The improvement comes from multiple factors: the multimodal outputs (AlphaGenome predicts downstream consequences on many tracks, providing richer clues to infer direction), the distillation training (which may smooth out noise and make the model more confident in sign), and possibly architectural changes like basepair-resolution outputs that capture subtle asymmetric effects. As a concrete example, AlphaGenome’s paper highlights a variant near the TAL1 oncogene where Enformer-based scoring had difficulty, but AlphaGenome clearly predicted that the mutation activated an enhancer to increase TAL1 expression. More generally, AlphaGenome was shown to recover far more true positive eQTLs at high precision when requiring correct direction: at 90% predicted sign accuracy, it captured 2× more eQTLs than the previous model (41% vs 19% of variants). This indicates that researchers can now filter variant hits by predicted direction with much greater confidence. In summary, AlphaGenome largely overcomes Enformer’s directional limitation by providing a model that not only predicts the magnitude of molecular changes caused by a variant but also correctly infers the polarity of the effect (gain or loss of function) across modalities. This is a critical advancement for variant interpretation, as knowing how a variant perturbs a gene or element (increasing vs decreasing activity) is key to linking variants to phenotypic outcomes.</p>
</section>
</section>
<section id="variant-effect-prediction-across-modalities" class="level2">
<h2 class="anchored" data-anchor-id="variant-effect-prediction-across-modalities">Variant Effect Prediction Across Modalities</h2>
<p>AlphaGenome was evaluated on a comprehensive suite of 26 variant effect prediction (VEP) benchmarks spanning diverse molecular phenotypes. The model demonstrated high accuracy in predicting variant consequences across multiple modalities, including splicing, gene expression, chromatin accessibility, and transcription factor (TF) binding. Here we examine each modality in turn, highlighting AlphaGenome’s performance and novel methodological features like splice junction modeling and composite scoring.</p>
<section id="splicing-variants-unified-splice-site-usage-and-junction-prediction" class="level3">
<h3 class="anchored" data-anchor-id="splicing-variants-unified-splice-site-usage-and-junction-prediction">Splicing Variants: Unified Splice Site, Usage, and Junction Prediction</h3>
<p>One of AlphaGenome’s most innovative aspects is its treatment of splicing. Previous models like SpliceAI focused on predicting whether a variant disrupts canonical splice sites (donors/acceptors), and others like Pangolin predicted splice site usage (percent spliced in, PSI) changes, but none directly predicted the formation of new splice junctions. AlphaGenome is the first system to jointly predict all three levels of splicing outcomes: (1) the probability of each nucleotide being a splice donor or acceptor, (2) the usage of each splice site (proportion of transcripts using that site), and (3) the presence and read count of specific splice junctions (introns) connecting two sites. By integrating these, AlphaGenome provides a holistic view of how a variant will alter splicing patterns. In practice, this means AlphaGenome can detect subtle splicing changes such as cryptic splice site activation, exon skipping, or novel exon creation, which are often missed by models that only score nearest splice sites.</p>
<p>Performance on Splicing Benchmarks: The model’s comprehensive splicing prediction translates into state-of-the-art results on numerous splicing variant benchmarks. AlphaGenome’s authors constructed a unified splicing variant scorer that combines the model’s various splicing outputs into a single composite score for a variant. This involves computing separate sub-scores for splice site disruption, changes in splice site usage (ΔPSI), and any new or lost junctions, then summing them into a composite metric. When evaluated on fine-mapped sQTLs (splicing QTLs) – variants associated with splicing changes in GTEx – AlphaGenome’s composite scorer achieved the highest accuracy in distinguishing true sQTL variants from negatives. It outperformed prior methods in both “nearby SNP” scenarios (variants within 200 bp of a splice site) and more distant variants affecting splicing up to 10 kb away. Similarly, on a task of predicting rare splice-disrupting variants (variants causing aberrant splicing in GTEx outlier samples), AlphaGenome again led both in unsupervised ranking and in a supervised setting.</p>
<p>Notably, in ClinVar pathogenicity classification for variants affecting splicing, AlphaGenome’s splicing scores beat the previous best method (Pangolin) in every category. For example, for deep intronic or synonymous variants that sometimes create cryptic splice sites, AlphaGenome achieved an auPRC of 0.66 vs 0.64 by Pangolin. In the “splice region” category (variants near exon-intron junctions), it scored 0.57 auPRC vs 0.55 for Pangolin, and even for missense variants (where splicing changes are an off-target effect) it edged out the competition (0.18 vs 0.16). The only benchmark where AlphaGenome did not rank first was a high-throughput splicing reporter assay (MFASS) for which Pangolin slightly exceeded it (auPRC 0.54 vs 0.51). Even there, AlphaGenome still outperformed other tools like SpliceAI and DeltaSplice (each 0.49). Interestingly, the authors found that the splice junction-specific sub-score alone (ignoring site disruption scores) was extremely powerful: it outperformed all prior methods on 5 of 7 benchmarks by itself. This underscores the value of explicit junction prediction – by modeling the creation or loss of specific exon-exon links, AlphaGenome captures effects that purely site-based models might miss. Overall, AlphaGenome was declared a “state-of-the-art splicing VEP model”, achieving SOTA on 6 of 7 tests. The rich splicing output not only improves accuracy but also provides mechanistic insight. For example, AlphaGenome correctly predicted a known case of exon skipping: a 4 bp deletion in the DLG1 gene that causes an exon to be skipped in arterial tissue. The model’s predictions showed reduced usage of the exon’s splice site, disappearance of junctions that include that exon, appearance of a junction skipping over it, and loss of RNA-seq coverage for that exon – precisely matching the experimental observation. In another example, it captured a novel splice junction created by a variant in the COL6A2 gene (Aorta tissue), which led to an extended exon; AlphaGenome’s junction and coverage predictions mirrored the GTEx RNA-seq evidence of that new splicing event. These case studies highlight how AlphaGenome’s fine-grained splicing predictions can pinpoint the exact nature of splicing alterations caused by variants, an ability that was lacking in earlier general models.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>